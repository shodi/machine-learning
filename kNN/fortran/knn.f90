MODULE KNN
    USE IRIS_DATA
    IMPLICIT NONE
    CONTAINS
    FUNCTION EUCLIDEAN_DISTANCE(POINT_1, POINT_2) RESULT(DISTANCE)
        IMPLICIT NONE
        REAL, DIMENSION(:) :: POINT_1, POINT_2
        REAL :: DISTANCE, PARTIAL_DISTANCE = 0
        INTEGER(KIND = 16) :: QTD_ATTR, I = 1

        ! Quantidade de atributos da inst√¢ncia
        QTD_ATTR = SIZE(POINT_1)

     10 CONTINUE
        IF (I .LE. QTD_ATTR) THEN
            PARTIAL_DISTANCE = PARTIAL_DISTANCE + (POINT_1(I) - POINT_2(I)) ** 2
            I = I + 1
            GOTO 10
        END IF

        DISTANCE = PARTIAL_DISTANCE

    END FUNCTION EUCLIDEAN_DISTANCE

    FUNCTION MEAN(LABELS) RESULT(PREDICTION)
        IMPLICIT NONE
        REAL, DIMENSION(:), INTENT(IN) :: LABELS
        REAL :: PREDICTION, PARTIAL_PREDICTION = 0
        INTEGER :: LABELS_SIZE, I = 1
        
        LABELS_SIZE = SIZE(LABELS)

     20 CONTINUE
        IF (I .LE. LABELS_SIZE) THEN
            PARTIAL_PREDICTION = PARTIAL_PREDICTION + LABELS(I)
            GOTO 20
        END IF

        PREDICTION = PARTIAL_PREDICTION / LABELS_SIZE
    END FUNCTION MEAN

    FUNCTION FIND_K_NEAREST_NEIGHBOR(K) RESULT(K_NEIGHBOR)
        INTEGER :: K, IO, I = 1
        DOUBLE PRECISION, DIMENSION(K) :: K_NEIGHBOR
        TYPE(IRIS_RECORD_LIST) :: IRIS_INSTANCES
        TYPE(IRIS_RECORD) :: CURRENT_RECORD

        OPEN(UNIT=18, FILE='./../iris.data', STATUS='OLD', ACCESS='SEQUENTIAL', FORM='FORMATTED', RECL=1)
     30 CONTINUE   
        READ(UNIT=18, FMT=*, IOSTAT=IO) CURRENT_RECORD
        IF (IO .LT. 0) GOTO 40
        CALL APPEND(IRIS_INSTANCES, CURRENT_RECORD)
        I = I + 1
        GOTO 30
     40 CLOSE(18)

        CALL PRINT_LIST(IRIS_INSTANCES)
    END FUNCTION FIND_K_NEAREST_NEIGHBOR
END MODULE KNN